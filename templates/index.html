<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Tinder Bot Dashboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" />
  <style>
    body {
      padding: 20px;
      transition: background-color 0.3s, color 0.3s;
    }
    body.dark-mode {
      background-color: #121212;
      color: #ffffff;
    }
    body.dark-mode .card {
      background-color: #1e1e1e;
      color: #ffffff;
    }
    body.dark-mode .form-control,
    body.dark-mode .form-select {
      background-color: #2a2a2a;
      color: #ffffff;
      border-color: #444;
    }
    body.dark-mode .page-link {
      background-color: #2a2a2a;
      color: #ffffff;
      border-color: #444;
    }
    .match-card {
      border: 1px solid #ccc;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 15px;
      opacity: 0;
      transform: translateY(20px);
      animation: slideIn 0.5s forwards ease-in-out;
      background-color: rgba(255, 255, 255, 0.05);
    }
    body.dark-mode .match-card {
      border-color: #444;
      background-color: rgba(255, 255, 255, 0.05);
    }
    @keyframes slideIn {
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    .match-card img {
      max-width: 100px;
      border-radius: 50%;
    }
    .match-actions button {
      margin-right: 5px;
    }
    .typing-entry {
      font-style: italic;
      color: gray;
      opacity: 0.8;
      animation: typingBlink 1.2s infinite;
    }
    @keyframes typingBlink {
      0% { opacity: 0.3; }
      50% { opacity: 1; }
      100% { opacity: 0.3; }
    }
    .typing-entry.fade-out {
      opacity: 0;
      transition: opacity 1.2s ease-out;
    }
    .btn {
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      border: 2px solid rgba(255, 255, 255, 0.1);
    }
    .btn:hover {
      transform: scale(1.03);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      border-color: rgba(255, 255, 255, 0.3);
    }
    .btn:active {
      transform: scale(0.98);
    }
    .btn-outline-light:hover {
      color: black;
      background-color: white;
    }
    #bot-status {
      font-weight: bold;
      margin-bottom: 1rem;
    }
    #toast-container .toast {
      transition: opacity 0.5s ease, transform 0.5s ease;
      z-index: 9999;
    }
    .auto-approved-card {
      border: 2px solid #4caf50;
      opacity: 0.85;
    }
    .sentiment-badge {
      font-size: 0.9em;
    }
    .quick-stats-panel {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 10px;
      padding: 20px;
      margin-bottom: 20px;
      color: white;
    }
    .quick-stats-panel .stat-item {
      text-align: center;
      padding: 10px;
    }
    .quick-stats-panel h6 {
      color: rgba(255, 255, 255, 0.8);
      margin-bottom: 5px;
      font-size: 0.9em;
    }
    .quick-stats-panel .stat-value {
      font-size: 1.8em;
      font-weight: bold;
    }
    .countdown-badge {
      font-size: 1.2em;
      padding: 8px 12px;
    }
    .spinner-border-sm {
      width: 1rem;
      height: 1rem;
      border-width: 0.2em;
    }
    /* small improvement: sticky bottom controls on mobile */
    @media (max-width: 576px) {
      .mobile-controls {
        position: fixed;
        bottom: 10px;
        left: 10px;
        right: 10px;
        z-index: 1050;
        display: flex;
        gap: 8px;
        justify-content: space-between;
      }
    }
  </style>
</head>
<body class="dark-mode">
  <div class="container py-4">
    <div class="text-center mb-4">
      <h1 class="display-4">üî• Tinder Bot</h1>
      <div class="text-light fw-light mt-2">AI-Powered Tinder Bot Dashboard</div>
    </div>

    <div id="bot-status" class="text-info">Bot Status: <span id="status-value">Checking...</span></div>

    <div class="d-flex justify-content-between align-items-center mb-4">
      <span></span>
      <div>
        <button id="toggle-theme" class="btn btn-outline-light me-2">üåì Toggle Theme</button>
        <button id="toggle-sound" class="btn btn-secondary">üîä Sound: On</button>
      </div>
    </div>

    <div class="d-flex flex-wrap gap-2 mb-4 justify-content-start">
      <button id="toggle-bot" class="btn btn-danger">Start Bot</button>
      <button id="toggle-auto-approve" class="btn btn-success">Auto-Approve: Off</button>
      <button id="toggle-auto-swipe" class="btn btn-warning">Auto-Swipe: Off</button>
      <button id="toggle-browser" class="btn btn-info">Mode: Browser</button>
      <button id="swipeBtn" class="btn btn-info">Swipe Now</button>
      <button id="start-browser-btn" class="btn btn-primary">üåê Start Browser</button>
    </div>

    <!-- Notification Sound -->
    <audio id="notification-sound" preload="auto">
      <source src="data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoG..." type="audio/wav">
    </audio>

    <!-- Toast Notification Container -->
    <div id="toast-container" style="position: fixed; top: 20px; right: 20px; z-index: 9999;"></div>

    <!-- Quick Stats Panel -->
    <div class="quick-stats-panel" id="quick-stats" style="display: none;">
      <div class="row">
        <div class="col-md-3 stat-item">
          <h6>Active Matches</h6>
          <div class="stat-value" id="quick-active-matches">0</div>
        </div>
        <div class="col-md-3 stat-item">
          <h6>Messages Today</h6>
          <div class="stat-value" id="quick-messages-today">0</div>
        </div>
        <div class="col-md-3 stat-item">
          <h6>Response Rate</h6>
          <div class="stat-value" id="quick-response-rate">0%</div>
        </div>
        <div class="col-md-3 stat-item">
          <h6>Bot Efficiency</h6>
          <div class="stat-value" id="quick-efficiency">0%</div>
        </div>
      </div>
    </div>
    
    <div class="row mb-4">
      <div class="col-md-3">
        <label for="personality-select" class="form-label">Personality</label>
        <select id="personality-select" class="form-select">
          <option value="default">Default (Josh)</option>
          <option value="flirty">Flirty</option>
          <option value="funny">Funny</option>
          <option value="gentle">Gentle</option>
        </select>
      </div>
      <div class="col-md-3">
        <label for="filter-input" class="form-label">Filter Matches</label>
        <input type="text" id="filter-input" class="form-control" placeholder="Type to filter..." />
      </div>
      <div class="col-md-2">
        <label for="match_limit" class="form-label">Match Limit</label>
        <input type="number" id="match_limit" class="form-control" value="100" min="1" max="500" />
      </div>
      <div class="col-md-2">
        <label for="swipe-interval" class="form-label">Swipe Interval (min)</label>
        <input type="number" id="swipe-interval" class="form-control" value="30" min="1" max="120" />
      </div>
      <div class="col-md-2">
        <label for="typing-delay-input" class="form-label">Typing Delay (s)</label>
        <input type="number" id="typing-delay-input" class="form-control" value="4" min="1" max="30" />
      </div>
    </div>

    <div class="row mb-4">
      <div class="col-md-3">
        <label for="max-tokens" class="form-label">Max Tokens</label>
        <input type="number" id="max-tokens" class="form-control" value="300" min="100" max="4000" />
      </div>
      <div class="col-md-6">
        <label for="uninteracted-limit" class="form-label">Message Unmatched</label>
        <div class="input-group">
          <input type="number" id="uninteracted-limit" class="form-control" value="5" min="1" max="50" />
          <button class="btn btn-primary" id="send-uninteracted-btn">Send Messages</button>
        </div>
      </div>
      <div class="col-md-3">
        <label class="form-label">Next Swipe</label>
        <div class="form-control-plaintext">
          <span id="countdown" class="badge bg-secondary countdown-badge">--:--</span>
        </div>
      </div>
    </div>

    <div id="match-container"></div>

    <div id="auto-approved-toggle-container" class="mt-4">
      <button id="toggle-auto-approved-btn" class="btn btn-dark">Show Auto-Approved</button>
    </div>

    <nav class="mt-3">
      <ul class="pagination">
        <li class="page-item"><button class="page-link" id="prev-page">Previous</button></li>
        <li class="page-item"><span class="page-link" id="current-page">1</span></li>
        <li class="page-item"><button class="page-link" id="next-page">Next</button></li>
      </ul>
    </nav>

    <div id="auto-approved-log-container" style="display:none;">
      <h5 class="text-success mt-3">ü§ñ Auto-Approved Matches</h5>
      <div id="auto-approved-container"></div>
    </div>

    <div class="card mt-5">
      <div class="card-header bg-info text-white">üìä Bot Statistics</div>
      <div class="card-body">
        <div class="row">
          <div class="col-md-6">
            <p><strong>Total Replies:</strong> <span id="total-replies" class="badge bg-primary">0</span></p>
            <p><strong>Total Matches:</strong> <span id="total-matches" class="badge bg-success">0</span></p>
            <p><strong>Approved:</strong> <span id="total-approved" class="badge bg-success">0</span></p>
            <p><strong>Rejected:</strong> <span id="total-rejected" class="badge bg-danger">0</span></p>
          </div>
          <div class="col-md-6">
            <p><strong>Likes Attempted:</strong> <span id="likes-attempted" class="badge bg-info">0</span></p>
            <p><strong>Matches Made:</strong> <span id="matches-made" class="badge bg-success">0</span></p>
            <p><strong>Bot Uptime:</strong> <span id="bot-uptime" class="badge bg-dark">--</span></p>
            <p><strong>Claude Tokens:</strong> <span id="claude-tokens" class="badge bg-warning text-dark">0</span></p>
          </div>
        </div>
        <div class="progress mt-3" style="height: 20px;">
          <div id="claude-token-bar" class="progress-bar bg-success" role="progressbar" style="width: 0%;">0%</div>
        </div>
        <div id="model-token-breakdown" class="mt-3"></div>
      </div>
    </div>
  </div>

  <!-- Socket.IO -->
  <script src="https://cdn.socket.io/4.4.1/socket.io.min.js"></script>
  <!-- Bootstrap JS -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  
  <script>
    console.log("Dashboard initializing...");

    // -----------------------
    // Socket.IO (if available)
    // -----------------------
    let socket = null;
    if (typeof io === 'undefined') {
      console.warn('Socket.IO not loaded, continuing without realtime socket events.');
      socket = { on: () => {}, emit: () => {}, connected: false };
    } else {
      try {
        socket = io();
        socket.on('connect', () => {
          console.log('Socket connected');
          showToast('Connected to server', 'success');
        });
        socket.on('disconnect', () => {
          console.log('Socket disconnected');
          showToast('Disconnected from server', 'warning');
        });
      } catch (e) {
        console.error('Socket.IO init error:', e);
        socket = { on: () => {}, emit: () => {}, connected: false };
      }
    }

    // -----------------------
    // Global state
    // -----------------------
    let matches = [];
    let autoMatches = [];
    let currentPage = 1;
    let autoApprovedPage = 1;
    const matchesPerPage = 10;
    const autoApprovedPerPage = 10;
    let soundEnabled = true;
    let nextSwipeTime = null;
    let botStartTime = null;
    let showAutoApproved = false;

    // Debug function
    function debugLog(message, data = '') {
      console.debug(`[Dashboard] ${message}`, data);
    }

    // -----------------------
    // Unified safeFetch helper
    // -----------------------
    async function safeFetch(url, method='GET', payload=null, { expectsJson=true } = {}) {
      /**
       * - method: 'GET'|'POST'|'PUT'|'DELETE' etc
       * - payload: object to be JSON.stringified for non-GET requests (ignored for GET)
       * - expectsJson: whether the response should be parsed as JSON (fallback to text)
       *
       * This helper:
       * - sets Content-Type for non-GET requests
       * - stringifies payload
       * - treats 204 No Content safely
       */
      const options = { method, headers: {} };

      if (method !== 'GET' && payload !== null && typeof payload === 'object') {
        options.headers['Content-Type'] = 'application/json';
        options.body = JSON.stringify(payload);
      }

      // If method is not GET but payload is null, we still want Content-Type sometimes
      if (method !== 'GET' && payload === null) {
        options.headers['Content-Type'] = 'application/json';
      }

      debugLog('safeFetch', { url, options });

      try {
        const response = await fetch(url, options);

        if (!response.ok) {
          const text = await response.text().catch(() => '');
          const msg = `HTTP ${response.status} ${response.statusText} - ${text}`;
          debugLog('safeFetch error', msg);
          const err = new Error(msg);
          err.status = response.status;
          throw err;
        }

        // No content
        if (response.status === 204) return null;

        // Try to parse JSON, otherwise return text
        if (expectsJson) {
          try {
            return await response.json();
          } catch (e) {
            debugLog('safeFetch: response not JSON, returning text', e);
            return await response.text();
          }
        } else {
          return await response.text();
        }
      } catch (err) {
        console.error(`Fetch failed for ${url}:`, err);
        // bubble up with message for UI
        throw err;
      }
    }

    // -----------------------
    // Toast & sound utilities
    // -----------------------
    function showToast(message, type='info', ttl=5000) {
      const toast = document.createElement("div");
      toast.className = `toast align-items-center text-white bg-${type} border-0 show`;
      toast.role = "alert";
      toast.style = `
        min-width: 250px;
        margin-bottom: 10px;
        padding: 10px 15px;
        border-radius: 6px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        animation: slideIn 0.3s ease-out;
      `;

      toast.innerHTML = `
        <div class="d-flex justify-content-between align-items-center">
          <div>${message}</div>
          <button type="button" class="btn-close btn-close-white ms-2"></button>
        </div>
      `;

      const container = document.getElementById("toast-container");
      container.prepend(toast);

      const closeBtn = toast.querySelector('.btn-close');
      closeBtn.addEventListener('click', () => toast.remove());

      setTimeout(() => {
        toast.style.opacity = '0';
        setTimeout(() => {
          if (toast.parentNode) toast.remove();
        }, 500);
      }, ttl);

      debugLog(`Toast: ${message}`);
    }

    function playNotificationSound() {
      if (!soundEnabled) return;
      try {
        const sound = document.getElementById("notification-sound");
        if (sound) {
          sound.currentTime = 0;
          sound.play().catch(err => debugLog('Sound blocked', err));
        }
      } catch (e) {
        debugLog('playNotificationSound error', e);
      }
    }

    // -----------------------
    // Countdown & uptime
    // -----------------------
    function updateCountdown() {
      if (!nextSwipeTime) {
        document.getElementById('countdown').textContent = '--:--';
        return;
      }
      const now = Date.now();
      const remaining = Math.max(0, nextSwipeTime - now);
      const minutes = Math.floor(remaining / 60000);
      const seconds = Math.floor((remaining % 60000) / 1000);
      document.getElementById('countdown').textContent =
        `${String(minutes).padStart(2,'0')}:${String(seconds).padStart(2,'0')}`;
      if (remaining === 0) {
        nextSwipeTime = null;
      }
    }

    function updateBotUptime() {
      if (!botStartTime) {
        document.getElementById('bot-uptime').textContent = '--';
        return;
      }
      const uptime = Math.floor((Date.now() - botStartTime)/1000);
      const hours = Math.floor(uptime/3600);
      const minutes = Math.floor((uptime%3600)/60);
      const seconds = uptime % 60;
      document.getElementById('bot-uptime').textContent = `${hours}h ${minutes}m ${seconds}s`;
    }

    // -----------------------
    // UI helpers
    // -----------------------
    function setToggleButtonState(btn, isOn, labels = { on: 'On', off: 'Off' }, classes = { on: 'btn-success', off: 'btn-danger' }) {
      btn.textContent = btn.dataset.labelPrefix ? `${btn.dataset.labelPrefix}: ${isOn ? labels.on : labels.off}` : (isOn ? labels.on : labels.off);
      btn.className = `btn ${isOn ? classes.on : classes.off}`;
      btn.dataset.state = isOn ? 'on' : 'off';
    }

    // -----------------------
    // DOM event wiring
    // -----------------------
    document.getElementById('toggle-theme').addEventListener('click', () => {
      document.body.classList.toggle('dark-mode');
      const isDark = document.body.classList.contains('dark-mode');
      localStorage.setItem('theme', isDark ? 'dark' : 'light');
      showToast(`Theme switched to ${isDark ? 'dark' : 'light'} mode`, 'info');
    });

    document.getElementById('toggle-sound').addEventListener('click', () => {
      soundEnabled = !soundEnabled;
      const btn = document.getElementById('toggle-sound');
      btn.textContent = `üîä Sound: ${soundEnabled ? 'On' : 'Off'}`;
      btn.className = soundEnabled ? 'btn btn-secondary' : 'btn btn-outline-secondary';
      localStorage.setItem('soundEnabled', soundEnabled);
      if (soundEnabled) playNotificationSound();
    });

    // -----------------------
    // Start Browser
    // -----------------------
    document.getElementById('start-browser-btn').addEventListener('click', async (e) => {
      const btn = e.currentTarget;
      const origText = btn.textContent;
      btn.disabled = true;
      btn.innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span>Starting Browser...';
      try {
        const data = await safeFetch('/start-browser', 'POST', {});
        if (data && data.status === 'ok') {
          btn.textContent = 'üåê Browser Running';
          btn.className = 'btn btn-success';
          showToast('Browser started! Complete login manually if needed.', 'success');
        } else {
          btn.textContent = origText;
          btn.className = 'btn btn-primary';
          showToast(`Browser failed: ${data && data.error ? data.error : 'Unknown error'}`, 'danger');
        }
      } catch (err) {
        btn.textContent = origText;
        btn.className = 'btn btn-primary';
        showToast('Failed to start browser', 'danger');
      } finally {
        btn.disabled = false;
      }
    });

    // -----------------------
    // Toggle Bot
    // -----------------------
    document.getElementById('toggle-bot').addEventListener('click', async (e) => {
      const btn = e.currentTarget;
      btn.disabled = true;
      try {
        const data = await safeFetch('/toggle-bot', 'POST', {});
        const enabled = !!(data && data.enabled);
        btn.textContent = enabled ? 'Stop Bot' : 'Start Bot';
        btn.className = enabled ? 'btn btn-primary' : 'btn btn-danger';
        document.getElementById('status-value').textContent = enabled ? 'üü¢ Running' : 'üî¥ Stopped';
        document.getElementById('status-value').className = enabled ? 'text-success' : 'text-danger';
        if (enabled) botStartTime = Date.now(); else botStartTime = null;
        showToast(`Bot ${enabled ? 'started' : 'stopped'}`, enabled ? 'success' : 'warning');
      } catch (err) {
        showToast('Failed to toggle bot', 'danger');
      } finally {
        btn.disabled = false;
      }
    });

    // -----------------------
    // Toggle Auto-Approve (optimistic update)
    // -----------------------
    document.getElementById('toggle-auto-approve').addEventListener('click', async (e) => {
      const btn = e.currentTarget;
      const currentlyOn = btn.dataset.state === 'on' || btn.textContent.includes('On');
      const newState = !currentlyOn;

      // optimistic update
      const prevClass = btn.className;
      const prevText = btn.textContent;
      setToggleButtonState(btn, newState, {on: 'On', off: 'Off'}, {on: 'btn btn-success', off: 'btn btn-danger'});
      btn.disabled = true;

      try {
        const res = await safeFetch('/toggle-auto-approve', 'POST', { auto_approve: newState });
        const serverState = res && typeof res.auto_approve !== 'undefined' ? res.auto_approve : newState;
        setToggleButtonState(btn, !!serverState, {on: 'On', off: 'Off'}, {on: 'btn btn-success', off: 'btn btn-danger'});
        showToast(`Auto-approve ${serverState ? 'enabled' : 'disabled'}`, 'success');
      } catch (err) {
        // rollback
        btn.className = prevClass;
        btn.textContent = prevText;
        showToast('Failed to toggle auto-approve', 'danger');
      } finally {
        btn.disabled = false;
      }
    });

    // -----------------------
    // Toggle Auto-Swipe (optimistic + nextSwipeTime calculation)
    // -----------------------
    document.getElementById('toggle-auto-swipe').addEventListener('click', async (e) => {
      const btn = e.currentTarget;
      const currentlyOn = btn.dataset.state === 'on' || btn.textContent.includes('On');
      const newState = !currentlyOn;

      // optimistic
      const prevClass = btn.className;
      const prevText = btn.textContent;
      setToggleButtonState(btn, newState, {on: 'On', off: 'Off'}, {on: 'btn btn-success', off: 'btn btn-warning'});
      btn.disabled = true;

      try {
        const res = await safeFetch('/toggle-auto-swipe', 'POST', { auto_swipe: newState });
        const serverState = res && typeof res.auto_swipe !== 'undefined' ? res.auto_swipe : newState;
        setToggleButtonState(btn, !!serverState, {on: 'On', off: 'Off'}, {on: 'btn btn-success', off: 'btn btn-warning'});

        if (serverState) {
          const interval = parseInt(document.getElementById('swipe-interval').value, 10) || 30;
          nextSwipeTime = Date.now() + interval * 60 * 1000;
        } else {
          nextSwipeTime = null;
        }
        showToast(`Auto-swipe ${serverState ? 'enabled' : 'disabled'}`, 'success');
      } catch (err) {
        btn.className = prevClass;
        btn.textContent = prevText;
        showToast('Failed to toggle auto-swipe', 'danger');
      } finally {
        btn.disabled = false;
      }
    });

    // -----------------------
    // Manual Swipe
    // -----------------------
    document.getElementById('swipeBtn').addEventListener('click', async (e) => {
      const btn = e.currentTarget;
      const origText = btn.textContent;
      btn.disabled = true;
      btn.innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span>Swiping...';
      try {
        const data = await safeFetch('/swipe-now', 'POST', {});
        const likes = (data && data.likes) || 0;
        const matchesNum = (data && data.matches) || 0;
        showToast(`Swipe completed! Likes: ${likes}, Matches: ${matchesNum}`, 'success');
      } catch (err) {
        showToast('Swipe failed', 'danger');
      } finally {
        btn.disabled = false;
        btn.textContent = origText;
      }
    });

    // -----------------------
    // Toggle Mode (browser/api)
    // -----------------------
    document.getElementById('toggle-browser').addEventListener('click', async (e) => {
      const btn = e.currentTarget;
      btn.disabled = true;
      try {
        // Determine desired new mode on server side by toggling
        const res = await safeFetch('/toggle-mode', 'POST', {});
        const mode = res && res.mode ? res.mode : 'browser';
        btn.textContent = `Mode: ${mode === 'browser' ? 'Browser' : 'API'}`;
        btn.className = mode === 'browser' ? 'btn btn-info' : 'btn btn-warning';
        showToast(`Switched to ${mode} mode`, 'success');
      } catch (err) {
        showToast('Failed to switch mode', 'danger');
      } finally {
        btn.disabled = false;
      }
    });

    // -----------------------
    // Send messages to uninteracted matches
    // -----------------------
    document.getElementById('send-uninteracted-btn').addEventListener('click', async (e) => {
      const btn = e.currentTarget;
      const limit = parseInt(document.getElementById('uninteracted-limit').value, 10) || 5;
      const origText = btn.textContent;
      btn.disabled = true;
      btn.innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span>Sending...';
      try {
        const res = await safeFetch('/send-uninteracted', 'POST', { limit });
        showToast(`Sent messages to ${res && res.sent ? res.sent : 0} matches`, 'success');
      } catch (err) {
        showToast('Failed to send messages', 'danger');
      } finally {
        btn.disabled = false;
        btn.textContent = origText;
      }
    });

    // -----------------------
    // Personality selector
    // -----------------------
    document.getElementById('personality-select').addEventListener('change', async (e) => {
      const personality = e.target.value;
      try {
        await safeFetch('/set-personality', 'POST', { personality });
        showToast(`Personality changed to ${personality}`, 'success');
      } catch (err) {
        showToast('Failed to change personality', 'danger');
      }
    });

    // -----------------------
    // Filter matches in the DOM
    // -----------------------
    document.getElementById('filter-input').addEventListener('input', (e) => {
      const filter = e.target.value.toLowerCase();
      filterMatches(filter);
    });

    function filterMatches(filter) {
      const cards = document.querySelectorAll('.match-card');
      cards.forEach(card => {
        const text = card.textContent.toLowerCase();
        card.style.display = text.includes(filter) ? 'block' : 'none';
      });
    }

    // -----------------------
    // Toggle Auto-Approved panel
    // -----------------------
    document.getElementById('toggle-auto-approved-btn').addEventListener('click', async (e) => {
      showAutoApproved = !showAutoApproved;
      const container = document.getElementById('auto-approved-log-container');
      const btn = e.currentTarget;
      if (showAutoApproved) {
        container.style.display = 'block';
        btn.textContent = 'Hide Auto-Approved';
        btn.className = 'btn btn-secondary';
        await loadAutoApprovedMatches();
      } else {
        container.style.display = 'none';
        btn.textContent = 'Show Auto-Approved';
        btn.className = 'btn btn-dark';
      }
    });

    // -----------------------
    // Pagination
    // -----------------------
    document.getElementById('prev-page').addEventListener('click', () => {
      if (currentPage > 1) { currentPage--; renderMatches(); }
    });
    document.getElementById('next-page').addEventListener('click', () => {
      const maxPage = Math.ceil(matches.length / matchesPerPage) || 1;
      if (currentPage < maxPage) { currentPage++; renderMatches(); }
    });

    // -----------------------
    // Render matches & helpers
    // -----------------------
    function renderMatches() {
      const container = document.getElementById('match-container');
      const start = (currentPage - 1) * matchesPerPage;
      const end = start + matchesPerPage;
      const pageMatches = matches.slice(start, end);
      container.innerHTML = '';

      if (!pageMatches || pageMatches.length === 0) {
        container.innerHTML = '<div class="alert alert-info">No matches to display</div>';
        document.getElementById('current-page').textContent = currentPage;
        updatePaginationButtons();
        return;
      }

      pageMatches.forEach((match, idx) => {
        const card = createMatchCard(match, start + idx);
        container.appendChild(card);
      });

      document.getElementById('current-page').textContent = currentPage;
      updatePaginationButtons();
    }

    function createMatchCard(match, index) {
      const card = document.createElement('div');
      card.className = 'match-card';
      card.style.animationDelay = `${index * 0.06}s`;
      card.dataset.matchId = match.id || '';

      card.innerHTML = `
        <div class="row align-items-center">
          <div class="col-md-2">
            <img src="${match.photo || 'https://via.placeholder.com/100'}" alt="${match.name || ''}" class="img-fluid">
          </div>
          <div class="col-md-6">
            <h5>${match.name || 'Unknown'}, ${match.age || '??'}</h5>
            <p class="text-muted">${match.bio || 'No bio available'}</p>
            <small class="text-muted">Matched: ${formatDate(match.matched_at)}</small>
            ${match.sentiment ? `<span class="badge bg-info sentiment-badge ms-2">${match.sentiment}</span>` : ''}
          </div>
          <div class="col-md-4 match-actions text-end">
            <button class="btn btn-sm btn-success" data-action="approve" data-id="${match.id}">‚úÖ Approve</button>
            <button class="btn btn-sm btn-danger" data-action="reject" data-id="${match.id}">‚ùå Reject</button>
            <button class="btn btn-sm btn-info" data-action="chat" data-id="${match.id}">üí¨ Chat</button>
          </div>
        </div>
        ${match.last_message ? `<div class="mt-2 p-2 bg-light rounded"><small><strong>Last message:</strong> ${match.last_message}</small></div>` : ''}
      `;

      // delegate actions
      const approveBtn = card.querySelector('button[data-action="approve"]');
      const rejectBtn = card.querySelector('button[data-action="reject"]');
      const chatBtn = card.querySelector('button[data-action="chat"]');

      if (approveBtn) approveBtn.addEventListener('click', () => approveMatch(match.id));
      if (rejectBtn) rejectBtn.addEventListener('click', () => rejectMatch(match.id));
      if (chatBtn) chatBtn.addEventListener('click', () => viewChat(match.id));

      return card;
    }

    function updatePaginationButtons() {
      const maxPage = Math.ceil(matches.length / matchesPerPage) || 1;
      document.getElementById('prev-page').parentElement.classList.toggle('disabled', currentPage === 1);
      document.getElementById('next-page').parentElement.classList.toggle('disabled', currentPage >= maxPage);
    }

    function formatDate(dateString) {
      if (!dateString) return 'Unknown';
      const d = new Date(dateString);
      if (isNaN(d.getTime())) return dateString;
      return d.toLocaleDateString() + ' ' + d.toLocaleTimeString();
    }

    // -----------------------
    // Match actions (approve/reject/chat)
    // -----------------------
    async function approveMatch(matchId) {
      try {
        await safeFetch(`/approve-match/${encodeURIComponent(matchId)}`, 'POST', {});
        showToast('Match approved!', 'success');
        updateMatchInList(matchId, { approved: true });
      } catch (err) {
        showToast('Failed to approve match', 'danger');
      }
    }

    async function rejectMatch(matchId) {
      try {
        await safeFetch(`/reject-match/${encodeURIComponent(matchId)}`, 'POST', {});
        showToast('Match rejected', 'warning');
        updateMatchInList(matchId, { rejected: true });
      } catch (err) {
        showToast('Failed to reject match', 'danger');
      }
    }

    function viewChat(matchId) {
      showToast('Opening chat (not implemented)', 'info');
      // implement a modal or navigation to chat page if you have one
    }

    function updateMatchInList(matchId, updates) {
      const i = matches.findIndex(m => m.id === matchId);
      if (i !== -1) {
        matches[i] = { ...matches[i], ...updates };
        renderMatches();
      }
    }

    // -----------------------
    // Auto-approved matches
    // -----------------------
    async function loadAutoApprovedMatches() {
      try {
        const data = await safeFetch('/auto-approved-matches', 'GET');
        autoMatches = (data && data.matches) ? data.matches : [];
        renderAutoApprovedMatches();
      } catch (err) {
        debugLog('Failed to load auto-approved matches', err);
        showToast('Failed to load auto-approved matches', 'danger');
      }
    }

    function renderAutoApprovedMatches() {
      const container = document.getElementById('auto-approved-container');
      container.innerHTML = '';
      if (!autoMatches || autoMatches.length === 0) {
        container.innerHTML = '<div class="alert alert-info">No auto-approved matches yet</div>';
        return;
      }
      autoMatches.forEach(match => {
        const card = document.createElement('div');
        card.className = 'match-card auto-approved-card';
        card.innerHTML = `
          <div class="row">
            <div class="col-md-8">
              <strong>${match.name}</strong> - Auto-approved at ${formatDate(match.approved_at)}
            </div>
            <div class="col-md-4 text-end">
              <button class="btn btn-sm btn-warning" data-id="${match.id}" data-action="review">Review</button>
            </div>
          </div>
        `;
        const btn = card.querySelector('button[data-action="review"]');
        if (btn) btn.addEventListener('click', () => reviewAutoApproved(match.id));
        container.appendChild(card);
      });
    }

    function reviewAutoApproved(matchId) {
      showToast('Review feature coming soon', 'info');
    }

    // -----------------------
    // Socket event handlers
    // -----------------------
    if (socket && socket.on) {
      socket.on('new_match', (data) => {
        debugLog('new_match', data);
        if (data) {
          matches.unshift(data);
          renderMatches();
          playNotificationSound();
          showToast(`New match: ${data.name || 'Unknown'}`, 'success');
          updateStats(); // fetch latest stats
        }
      });

      socket.on('new_message', (data) => {
        debugLog('new_message', data);
        if (data && data.match_id) {
          updateMatchInList(data.match_id, { last_message: data.message });
          playNotificationSound();
          showToast(`New message from ${data.name || 'someone'}`, 'info');
        }
      });

      socket.on('bot_status', (data) => {
        debugLog('bot_status', data);
        const running = !!(data && data.running);
        document.getElementById('status-value').textContent = running ? 'üü¢ Running' : 'üî¥ Stopped';
        document.getElementById('status-value').className = running ? 'text-success' : 'text-danger';
      });

      socket.on('stats_update', (data) => {
        debugLog('stats_update', data);
        updateStatsDisplay(data);
      });

      socket.on('error', (err) => {
        console.error('Socket error', err);
        showToast(`Socket error: ${err && err.message ? err.message : 'unknown'}`, 'danger');
      });
    }

    // -----------------------
    // Stats updating
    // -----------------------
    function updateStatsDisplay(stats) {
      if (!stats) return;
      if (typeof stats.total_replies !== 'undefined') document.getElementById('total-replies').textContent = stats.total_replies;
      if (typeof stats.total_matches !== 'undefined') document.getElementById('total-matches').textContent = stats.total_matches;
      if (typeof stats.approved !== 'undefined') document.getElementById('total-approved').textContent = stats.approved;
      if (typeof stats.rejected !== 'undefined') document.getElementById('total-rejected').textContent = stats.rejected;
      if (typeof stats.likes_attempted !== 'undefined') document.getElementById('likes-attempted').textContent = stats.likes_attempted;
      if (typeof stats.matches_made !== 'undefined') document.getElementById('matches-made').textContent = stats.matches_made;
      if (typeof stats.claude_tokens !== 'undefined') {
        document.getElementById('claude-tokens').textContent = stats.claude_tokens;
        updateTokenBar(stats.claude_tokens);
      }
      // Quick stats panel (if the fields exist)
      if (typeof stats.active_matches !== 'undefined') document.getElementById('quick-active-matches').textContent = stats.active_matches;
      if (typeof stats.messages_today !== 'undefined') document.getElementById('quick-messages-today').textContent = stats.messages_today;
      if (typeof stats.response_rate !== 'undefined') document.getElementById('quick-response-rate').textContent = `${stats.response_rate}%`;
      if (typeof stats.bot_efficiency !== 'undefined') document.getElementById('quick-efficiency').textContent = `${stats.bot_efficiency}%`;
    }

    function updateTokenBar(tokens) {
      const maxTokens = 1000000;
      const percentage = Math.min(100, (tokens / maxTokens) * 100);
      const bar = document.getElementById('claude-token-bar');
      bar.style.width = `${percentage}%`;
      bar.textContent = `${percentage.toFixed(1)}%`;
      bar.className = 'progress-bar';
      if (percentage > 80) bar.classList.add('bg-danger');
      else if (percentage > 60) bar.classList.add('bg-warning');
      else bar.classList.add('bg-success');
    }

    async function updateStats() {
      try {
        const data = await safeFetch('/stats', 'GET');
        updateStatsDisplay(data);
      } catch (err) {
        debugLog('updateStats failed', err);
      }
    }

    // -----------------------
    // Initial load
    // -----------------------
    async function loadInitialData() {
      try {
        debugLog('Loading initial data');
        // config
        const config = await safeFetch('/config', 'GET');
        if (config) {
          const botEnabled = !!config.bot_enabled;
          const autoApprove = !!config.auto_approve;
          const autoSwipe = !!config.auto_swipe;
          document.getElementById('toggle-bot').textContent = botEnabled ? 'Stop Bot' : 'Start Bot';
          document.getElementById('toggle-bot').className = botEnabled ? 'btn btn-primary' : 'btn btn-danger';
          document.getElementById('toggle-auto-approve').dataset.labelPrefix = 'Auto-Approve';
          document.getElementById('toggle-auto-swipe').dataset.labelPrefix = 'Auto-Swipe';
          setToggleButtonState(document.getElementById('toggle-auto-approve'), autoApprove, {on:'On',off:'Off'}, {on:'btn btn-success',off:'btn btn-danger'});
          setToggleButtonState(document.getElementById('toggle-auto-swipe'), autoSwipe, {on:'On',off:'Off'}, {on:'btn btn-success',off:'btn btn-warning'});
          document.getElementById('status-value').textContent = botEnabled ? 'üü¢ Running' : 'üî¥ Stopped';
          document.getElementById('status-value').className = botEnabled ? 'text-success' : 'text-danger';
          if (botEnabled) botStartTime = Date.now();
        }

        // matches
        try {
          const matchData = await safeFetch('/matches', 'GET');
          matches = (matchData && matchData.matches) ? matchData.matches : [];
          renderMatches();
        } catch (e) {
          debugLog('Failed to load matches', e);
        }

        // stats
        await updateStats();

        // show quick stats
        document.getElementById('quick-stats').style.display = 'block';

        showToast('Dashboard ready!', 'success');
        debugLog('Initial data loaded');
      } catch (err) {
        debugLog('Failed to load initial data', err);
        showToast('Failed to load configuration', 'danger');
      }
    }

    // -----------------------
    // Preferences
    // -----------------------
    function loadPreferences() {
      const theme = localStorage.getItem('theme');
      if (theme === 'light') document.body.classList.remove('dark-mode');
      const sound = localStorage.getItem('soundEnabled');
      if (sound === 'false') {
        soundEnabled = false;
        document.getElementById('toggle-sound').textContent = 'üîä Sound: Off';
        document.getElementById('toggle-sound').className = 'btn btn-outline-secondary';
      }
    }

    // -----------------------
    // Intervals & visibility
    // -----------------------
    setInterval(updateCountdown, 1000);
    setInterval(updateBotUptime, 1000);
    setInterval(updateStats, 30000);

    document.addEventListener('visibilitychange', () => {
      if (!document.hidden) updateStats();
    });

    // -----------------------
    // DOMContentLoaded init
    // -----------------------
    document.addEventListener('DOMContentLoaded', () => {
      debugLog('Dashboard loaded');
      loadPreferences();
      loadInitialData();
    });

    debugLog('Dashboard script loaded');
  </script>
</body>
</html>
